% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/splendid_process.R
\name{splendid_process}
\alias{splendid_process}
\title{Process data}
\usage{
splendid_process(
  data,
  class,
  algorithms,
  convert = FALSE,
  standardize = FALSE,
  sampling = c("none", "up", "down", "smote"),
  seed_samp = NULL
)
}
\arguments{
\item{data}{data frame with rows as samples, columns as features}

\item{class}{true/reference class vector used for supervised learning}

\item{algorithms}{character vector of algorithms to use for supervised
learning. See \strong{Algorithms} section for possible options. By default,
this argument is \code{NULL}, in which case all algorithms are used.}

\item{convert}{logical; if \code{TRUE}, converts all categorical variables in
\code{data} to dummy variables. Certain algorithms only work with such
limitations (e.g. LDA).}

\item{standardize}{logical; if \code{TRUE}, the training sets are standardized on
features to have mean zero and unit variance. The test sets are
standardized using the vectors of centers and standard deviations used in
corresponding training sets.}

\item{sampling}{the default is "none", in which no subsampling is performed.
Other options include "up" (Up-sampling the minority class), "down"
(Down-sampling the majority class), and "smote" (synthetic points for the
minority class and down-sampling the majority class). Subsampling is only
applicable to the training set.}

\item{seed_samp}{random seed used for reproducibility in subsampling
training sets for model generation}
}
\value{
A pre-processed data frame for model training
}
\description{
Process the data by converting categorical predictors to dummy variables,
standardizing continuous predictors, and apply subsampling techniques.
}
\details{
If all the variables in the original data are already continuous, nothing is
done. Otherwise, conversion is performed if \code{convert = TRUE} using
\code{\link[=dummify]{dummify()}}. An error message is thrown if there are categorical variables
and \code{convert = FALSE}, indicating exactly which algorithms specified require
data conversion. Classification algorithms LDA and the MLR family have such a
limitation.

Continuous predictors can be scaled to have zero mean and unit variance with
\code{standardize = TRUE}. Dummy variables coded to 0 or 1 are never standardized.

Subsampling techniques can be applied with \code{sampling} methods passed to
\code{\link[=subsample]{subsample()}}.
}
\examples{
data(hgsc)
cl <- attr(hgsc, "class.true")

# Nothing happens if data is all continuous
data_same <- splendid_process(hgsc, class = cl, algorithms = "lda", convert =
TRUE)
identical(hgsc, data_same)

# Dummy variables created if there are categorical variables
data_dummy <- splendid_process(iris, class = iris$Species, algorithms =
"lda", convert = TRUE)
head(data_dummy)

# Some algorithms are robust to the covariate data structure
data_robust <- splendid_process(iris, class = iris$Species, algorithms =
"rf", convert = FALSE)
identical(iris, data_robust)

# Standardize and down-sample
iris2 <- iris[1:130, ]
data_scale_down <- splendid_process(iris2, class = iris2$Species, algorithms
= "rf", standardize = TRUE, sampling = "down")
dim(data_scale_down)

# Other algorithms require conversion
\dontrun{
splendid_process(iris, class = iris$Species, algorithms = "lda", convert =
FALSE)
}
}
\seealso{
\code{\link[=dummify]{dummify()}}, \code{\link[=subsample]{subsample()}}
}
\author{
Derek Chiu
}
